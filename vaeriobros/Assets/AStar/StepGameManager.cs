using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Assets.Model;

public struct GapInfo
{
    public float LeftHeight { get; private set; }
    public float RightHeight { get; private set; }
    public float MinHeight { get; }
    public float MaxHeight { get; }

    public GapInfo(float leftHeight, float rightHeight)
    {
        LeftHeight = leftHeight;
        RightHeight = rightHeight;
        MinHeight = Mathf.Min(LeftHeight, RightHeight);
        MaxHeight = Mathf.Max(LeftHeight, RightHeight);
    }

    public override string ToString()
    {
        return string.Format("Gap({0:F},{1:F})", LeftHeight, RightHeight);
    }

}

public class StepGameManager : GameManager
{
    // levels generated by our VAE which were used for testing.
    // the last second to last level is difficult for the agent and the last one is unsolvable
    string[] testLevels = new string[]
    {
        "[[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,5,2,2,2,2,2,2,2,2,2,2,2],[2,6,7,2,2,2,2,2,2,2,5,2,2,2],[2,8,9,2,2,2,2,2,2,6,7,2,2,2],[2,8,9,2,2,2,2,2,2,8,9,2,2,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[1,1,1,1,1,1,1,1,1,1,1,1,1,1],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,5,2],[2,2,2,2,2,2,2,2,2,2,2,6,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,9,2],[2,2,2,2,2,2,2,2,2,2,2,8,5,2],[2,2,2,2,2,2,2,2,5,2,2,6,7,2],[2,5,2,2,2,2,2,6,7,2,2,8,9,2],[2,7,2,2,2,2,2,8,9,2,2,8,9,2],[2,9,2,2,2,2,2,8,9,2,2,8,9,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,5,2,2,2,2,2,2,2,2,2,2,2],[2,2,0,0,0,0,0,0,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[0,0,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,0,0,0,2,2,2,2,2],[2,2,2,2,2,2,0,0,0,2,2,2,2,2],[2,2,2,2,0,0,0,0,0,2,2,2,2,2],[2,2,2,0,0,0,0,0,0,2,2,2,2,2],[2,2,0,0,0,0,0,0,0,2,2,2,2,2],[2,0,0,0,0,0,0,0,0,2,2,2,2,2],[0,0,0,0,0,0,0,0,0,2,2,2,2,2],[0,0,0,0,0,0,0,0,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,1,1,1,1,1,2,2,2],[2,2,2,2,0,0,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,0,0,2,0,0,0,0,0,2,2,2,2]]]",
        "[[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,5,2,2,2,2,2,2,2,2,2,2,2,2],[6,7,2,2,2,2,2,2,2,2,2,2,2,2],[8,9,2,2,2,2,2,2,2,2,2,2,2,2],[8,9,2,2,2,2,2,2,2,2,2,2,2,2],[8,9,2,2,2,2,2,2,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,1,1,1,1,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,3,2,2,2,2,2,0,0,0,0,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[5,2,2,2,0,0,0,2,2,2,2,2,2,2],[2,2,2,0,0,0,0,2,2,2,2,2,2,2],[2,0,0,0,0,0,0,2,2,2,2,2,2,2],[2,2,2,2,2,2,0,2,2,2,2,2,2,2],[0,0,0,0,0,0,0,2,2,2,2,2,2,2],[8,9,0,0,0,0,0,5,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,0,2,2,2,2,2],[2,0,0,0,0,0,0,0,2,2,2,2,2,2],[0,0,2,2,2,2,2,2,2,2,2,2,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[5,2,2,2,0,0,0,2,2,2,2,2,2,2],[2,2,2,0,0,0,0,2,2,2,2,2,2,2],[2,2,5,0,0,0,0,2,2,2,2,2,2,2],[2,0,0,0,0,0,0,2,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,2,2,2,2,2,2],[0,0,0,0,0,0,0,2,2,2,2,2,2,2],[0,0,0,2,2,0,0,0,2,0,0,0,0,0]]]",
        "[[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,5,5,2,2,5,2,2,2],[2,2,2,2,2,2,0,0,0,0,0,0,0,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[0,0,0,0,0,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[0,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,1,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,0,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,0,0,0,0,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,0,0,0,0,0,0,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,0,2,2,2,2,2,2,2,2,2],[2,2,0,0,0,0,0,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,0,0,0,0,2,2,2,2,2,2,2,2,2],[0,0,0,0,0,0,2,2,2,2,2,2,2,2],[0,0,0,0,0,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,1],[0,0,0,2,2,2,2,2,2,2,2,0,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,0,0,0,0,2,2,2,2,2],[2,2,2,2,0,0,0,0,0,2,2,2,2,2],[2,2,2,5,5,0,0,0,0,2,2,2,2,2],[2,2,0,0,0,0,0,0,0,2,2,2,2,2],[2,0,0,0,0,0,0,0,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,0,2,2,2,2,2],[2,2,2,2,2,2,2,2,0,2,2,2,2,2],[2,2,2,2,2,2,2,0,0,2,2,2,2,2],[2,2,2,2,2,2,2,0,0,2,2,2,2,2],[2,2,2,2,2,2,0,0,0,2,2,2,2,2],[2,2,2,2,2,0,0,0,0,2,2,2,2,2],[2,2,2,0,0,0,0,0,0,2,2,2,2,2],[2,2,2,2,2,0,0,0,0,2,2,2,2,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,0]]]",
        "[[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,5,2,2,2,0,0,0,2,2,2,2],[2,2,2,2,2,0,0,0,0,0,2,2,2,2],[2,2,2,2,5,0,0,0,0,0,2,2,2,2],[2,2,2,0,0,0,0,0,0,0,2,2,2,2],[2,2,6,7,0,0,0,0,0,0,2,2,2,2],[5,2,0,0,0,0,0,0,0,0,2,2,2,2],[2,0,8,0,0,0,0,0,0,0,2,2,2,2],[0,0,8,9,0,0,0,0,0,0,2,2,2,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,1,2,1,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,5,2,2,2],[2,2,2,2,2,2,2,2,2,2,7,2,2,6],[2,2,5,2,2,6,5,2,2,8,9,2,2,8],[2,6,7,2,2,6,7,2,2,8,9,2,2,8],[2,8,9,2,2,8,9,2,2,8,9,2,2,8],[9,8,9,2,2,8,9,2,2,8,9,2,2,8],[2,0,0,0,2,0,0,0,0,0,0,0,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[1,1,1,1,1,1,1,1,1,1,1,1,1,1],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[1,1,2,1,2,2,2,2,2,2,2,2,1,1],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[1,1,1,1,2,2,2,2,2,2,2,2,1,1],[1,1,2,2,2,2,2,2,2,2,2,2,2,1],[1,2,2,1,1,1,2,2,2,2,2,2,2,1],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,1,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,5,2,5,5,2,5],[2,2,2,2,2,2,2,0,0,0,0,0,0,0],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,0,0,0,0,0,2,2,2,2,2,2,2],[0,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[1,2,1,2,2,2,2,2,2,2,2,2,2,2],[0,0,0,0,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2]]]",
        "[[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,0,0,0,0,0,0,0,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,0,0,2,2,2,2,2,2,2,2],[2,2,2,0,0,0,0,2,2,2,2,2,2,2],[2,0,0,0,0,0,0,2,2,2,2,2,2,2],[0,0,0,0,0,0,0,2,2,2,2,2,2,2],[0,0,0,0,0,0,2,2,2,2,0,0,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[0,0,0,0,0,0,0,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,1,1,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,0,0,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,5,2,2,2,2,2],[2,2,2,2,2,2,2,6,7,2,2,2,2,2],[2,2,2,2,2,2,2,8,9,2,2,2,2,2],[2,2,2,2,2,2,2,8,9,2,2,2,2,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,0]],[[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,2,2,2,2,2,2],[1,1,1,1,1,2,2,0,0,0,0,2,2,2],[1,1,5,5,5,1,5,0,0,0,0,2,5,2],[2,2,2,2,7,2,0,0,0,0,0,6,7,2],[2,2,2,6,7,0,0,0,0,0,2,8,2,2],[2,2,6,5,5,0,6,0,0,0,0,2,9,2],[1,8,6,6,7,0,0,0,0,0,8,8,9,9],[2,2,8,8,9,0,0,0,0,0,0,8,9,2],[2,0,8,8,9,0,0,0,0,0,2,8,9,1],[0,0,0,0,0,0,0,0,0,0,1,1,2,2],[0,0,0,0,0,0,0,0,0,0,0,0,2,2]]]"
    };

    // "speeds up" the physics simulation by increasing the simulated time per step
    [System.NonSerialized]
    public float speedup = 7;

    // number of actions before the agents assumes that it got stuck and restarts
    [System.NonSerialized]
    public int maxActionsBeforeRestart = 500;

    // the currently tested level
    string currentLevel;
    // the index of the currently tested level in the testLevels array
    int currentIndex;


    [SerializeField] bool showGapDebug = false;
    public GapInfo[] gapData = null;
    public float[] floorHeights = null;

    public List<Vector2> currentPlan; // the current plan positions for Drawing Gizmos


    protected override void OnStart()
    {
        currentIndex = 0;
        currentLevel = testLevels[currentIndex];
        StartCoroutine(RunSimulation());
    }

    protected override void ProcessGameEnd(EndReason reason)
    {

    }

    protected override void ProcessGameStart()
    {
        Physics2D.simulationMode = SimulationMode2D.Script;

        StartCoroutine(Optimize());
    }


    /// <summary>
    /// run the plan. Repetitions is the number of steps we repeated during planning
    /// </summary>
    /// <param name="actions"></param>
    /// <param name="repetitions"></param>
    /// <returns></returns>
    IEnumerator RunPlan(List<bool[]> actions, int repetitions)
    {
        foreach (bool[] action in actions)
        {
            for (int i = 0; i < repetitions; i++)
            {
                yield return new WaitForSeconds(0.02f);
                SingleStep(action);
            }
        }
    }

    IEnumerator Optimize()
    {
        AStarSimulator simulator = new AStarSimulator();
        int actions = 0;
        while (true)
        {
            actions += 1;
            bool[] action = simulator.optimise();
            currentPlan = simulator.currentPlanPositions;
            // bool[] action = AStarSimulator.createAction(false, true, false);
            SingleStep(action);
            yield return new WaitForSeconds(0.02f);
            if (plumber.thisRigidbody.position.y < KillHeight)
            {
                Debug.Log("Dead");
                Debug.Log("Actions:" + actions);
                break;
            }
            if (plumber.thisRigidbody.position.x > procLevel.LevelWidth - 3) // the actual goal is on the second to last column and we want to be generous since the agent is afraid of the gap at the end of the level
            {
                Debug.Log("Done");
                Debug.Log("Actions:" + actions);
                // load the next level
                currentIndex += 1;
                currentLevel = testLevels[currentIndex];
                break;
            }
            if (actions > maxActionsBeforeRestart)
            {
                Debug.Log("Restart");
                break;
            }
        }
        StartCoroutine(RunSimulation());
    }

    public void OnDrawGizmos()
    {
        Gizmos.color = new Color(1, 0, 0, 1f);
        foreach (Vector2 planPosition in currentPlan)
        {
            Gizmos.DrawSphere(planPosition, 0.2f);
        }

        /* the bool is not working for me
        if (showGapDebug)
        {
            if (gapData == null)
            {
                return;
            }
            Gizmos.color = new Color(0, 1, 0, 0.5f);

            for (int i = 0; i < gapData.Length; i++)
            {
                var gap = gapData[i];
                if (gap.MaxHeight > 0)
                {
                    var center = new Vector3(i, -0.5f + gap.MinHeight / 2, 0);
                    var size = new Vector3(1, gap.MinHeight, 0.1f);
                    Gizmos.DrawCube(center, size);
                }
            }

            Gizmos.color = new Color(0, 0, 1, 0.5f);
            for (int i = 0; i < gapData.Length; i++)
            {
                var gap = gapData[i];
                if (gap.MaxHeight > 0)
                {
                    var center = new Vector3(i, -0.5f + gap.MaxHeight / 2, 0);
                    var size = new Vector3(1, gap.MaxHeight, 0.1f);
                    Gizmos.DrawCube(center, size);
                }
            }

            if (floorHeights == null)
            {
                return;
            }

            Gizmos.color = new Color(1, 0, 0, 0.5f);
            for (int i = 0; i < floorHeights.Length; i++)
            {
                var height = floorHeights[i];
                if (height > 0)
                {
                    var center = new Vector3(i, -0.5f + height / 2, 0);
                    var size = new Vector3(1, height, 0.1f);
                    Gizmos.DrawCube(center, size);
                }
            }
        }
        */
    }

    public void AnalyseLevel()
    {
        gapData = new GapInfo[procLevel.LevelWidth];
        floorHeights = new float[procLevel.LevelWidth];
        for (int i = 0; i < procLevel.LevelWidth; i++)
        {
            Vector2 floorPos = new Vector2(i, 0);
            Vector2 ceilingPos = new Vector2(i, procLevel.LevelHeight);

            // check occupancy
            var obs = Physics2D.OverlapPoint(floorPos, SharedData.SolidLayers);
            if (obs != null)
            {
                floorHeights[i] = 0;
                continue;
            }
            else
            {
                floorHeights[i] = Mathf.Infinity;
                gapData[i] = AnalyseGap(floorPos, procLevel.LevelHeight, procLevel.ChunkWidth);
            }
            // linecast upwards
            var hit = Physics2D.Linecast(floorPos, ceilingPos, SharedData.SolidLayers);
            // only measure a "gap" if there is no ceiling
            if (hit.collider == null)
            {
                floorHeights[i] = Mathf.Infinity;
                gapData[i] = AnalyseGap(floorPos, procLevel.LevelHeight, procLevel.ChunkWidth);
            }
            else
            {
                floorHeights[i] = Mathf.CeilToInt(hit.distance);
            }
        }
    }

    private GapInfo AnalyseGap(Vector2 floorPos, int levelHeight, int chunkWidth)
    {
        //const float HALF_TILE_HEIGHT = 0.5f;
        int closestLeft = chunkWidth;
        int closestRight = chunkWidth;

        bool needLeft = true;
        float leftHeight = 0;
        bool needRight = true;
        float rightHeight = 0;
        for (int i = 0; i < levelHeight; i++)
        {
            // calculate end points
            var midPos = new Vector2(floorPos.x, i);
            var leftPos = new Vector2(floorPos.x - closestLeft, i);
            var rightPos = new Vector2(floorPos.x + closestRight, i);
            // check left
            if (needLeft)
            {
                var leftHit = Physics2D.Linecast(midPos, leftPos, SharedData.SolidLayers);
                if (leftHit.collider == null)
                {
                    leftHeight = i;
                    needLeft = false;
                }
                else
                {
                    var dist = Mathf.CeilToInt(leftHit.distance);
                    if (dist < closestLeft)
                    {
                        closestLeft = dist;
                    }
                }
            }
            // check right
            if (needRight)
            {
                var rightHit = Physics2D.Linecast(midPos, rightPos, SharedData.SolidLayers);
                // if we hit nothing, we found the minimum height
                if (rightHit.collider == null)
                {
                    rightHeight = i;
                    needRight = false;
                }
                else
                {
                    var dist = Mathf.CeilToInt(rightHit.distance);
                    if (dist < closestRight)
                    {
                        closestRight = dist;
                    }
                }
            }


        }
        return new GapInfo(leftHeight, rightHeight);
    }

    IEnumerator RunSimulation()
    {
        state = GameState.Loading;
        // clear any existing level
        Time.timeScale = 1;
        followCam.Target = null;
        plumber = null;
        if (procLevel != null)
        {
            procLevel.DestroyLevel();
        }
        List<Chunk> chunks = LoadCurrentLevel();
        // create a new level
        procLevel = Instantiate<ProcLevel>(procLevelPrefab, this.transform);
        procLevel.Generate(chunks, false);
        // link objects in level
        RecurseLinkObjects(procLevel.transform);
        yield return new WaitForEndOfFrame();
        AnalyseLevel();
        yield return new WaitForEndOfFrame();
        // launch game
        ProcessGameStart();
    }

    List<Chunk> LoadCurrentLevel()
    {
        var chunks = new List<Chunk>();

        var ls = JsonConvert.DeserializeObject<List<List<List<int>>>>(currentLevel);
        foreach (var l in ls)
        {
            //make chunk
            var chunk = new Chunk();
            chunk.sizeY = l.Count;
            chunk.sizeX = l.Count;
            foreach (var row in l)
            {
                foreach (var item in row)
                {
                    chunk.blocks.Add((BlockType)item);
                }
            }
            chunks.Add(chunk);
        }
        return chunks;
    }

    /// <summary>
    ///  do a single step of the environment
    /// </summary>
    /// <param name="action"></param>
    public void SingleStep(bool[] action)
    {
        plumber.jumpInput = 0;
        plumber.walkInput = 0;
        if (action[(int)Actions.Left])
        {
            plumber.walkInput = -1;
        }
        if (action[(int)Actions.Right])
        {
            plumber.walkInput = 1;
        }
        if (action[(int)Actions.Jump])
        {
            plumber.jumpInput = 1;
        }
        plumber.PhysiscsStep();
        Physics2D.Simulate(speedup * Time.fixedDeltaTime);
        Physics2D.SyncTransforms();
    }
}
